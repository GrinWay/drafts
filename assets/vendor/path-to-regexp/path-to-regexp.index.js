/**
 * Bundled by jsDelivr using Rollup v2.79.1 and Terser v5.19.2.
 * Original file: /npm/path-to-regexp@8.2.0/dist/index.js
 *
 * Do NOT use SRI with dynamically generated files! More information: https://www.jsdelivr.com/using-sri-with-dynamic-files
 */
var e={};Object.defineProperty(e,"__esModule",{value:!0});var t=e.TokenData=void 0,n=e.parse=h,r=e.compile=function(e,t={}){const{encode:n=encodeURIComponent,delimiter:r=u}=t,o=$((e instanceof m?e:h(e,t)).tokens,r,n);return function(e={}){const[t,...n]=o(e);if(n.length)throw new TypeError(`Missing parameters: ${n.join(", ")}`);return t}},o=e.match=function(e,t={}){const{decode:n=decodeURIComponent,delimiter:r=u}=t,{regexp:o,keys:i}=g(e,t),s=i.map((e=>!1===n?a:"param"===e.type?n:e=>e.split(r).map(n)));return function(e){const t=o.exec(e);if(!t)return!1;const n=t[0],r=Object.create(null);for(let e=1;e<t.length;e++){if(void 0===t[e])continue;const n=i[e-1],o=s[e-1];r[n.name]=o(t[e])}return{path:n,params:r}}},i=e.pathToRegexp=g,s=e.stringify=function(e){return e.tokens.map((function e(t,n,r){if("text"===t.type)return t.value.replace(/[{}()\[\]+?!:*]/g,"\\$&");if("group"===t.type)return`{${t.tokens.map(e).join("")}}`;const o=function(e){const[t,...n]=e;return!!p.test(t)&&n.every((e=>c.test(e)))}(t.name)&&function(e){return"text"!==(null==e?void 0:e.type)||!c.test(e.value[0])}(r[n+1]),i=o?t.name:JSON.stringify(t.name);if("param"===t.type)return`:${i}`;if("wildcard"===t.type)return`*${i}`;throw new TypeError(`Unexpected token: ${t}`)})).join("")};const u="/",a=e=>e,p=/^[$_\p{ID_Start}]$/u,c=/^[$\u200c\u200d\p{ID_Continue}]$/u,f="https://git.new/pathToRegexpError",l={"{":"{","}":"}","(":"(",")":")","[":"[","]":"]","+":"+","?":"?","!":"!"};function y(e){return e.replace(/[.+*?^${}()[\]|/\\]/g,"\\$&")}class d{constructor(e){this.tokens=e}peek(){if(!this._peek){const e=this.tokens.next();this._peek=e.value}return this._peek}tryConsume(e){const t=this.peek();if(t.type===e)return this._peek=void 0,t.value}consume(e){const t=this.tryConsume(e);if(void 0!==t)return t;const{type:n,index:r}=this.peek();throw new TypeError(`Unexpected ${n} at ${r}, expected ${e}: ${f}`)}text(){let e,t="";for(;e=this.tryConsume("CHAR")||this.tryConsume("ESCAPED");)t+=e;return t}}class m{constructor(e){this.tokens=e}}function h(e,t={}){const{encodePath:n=a}=t,r=new d(function*(e){const t=[...e];let n=0;function r(){let e="";if(p.test(t[++n]))for(e+=t[n];c.test(t[++n]);)e+=t[n];else if('"'===t[n]){let r=n;for(;n<t.length;){if('"'===t[++n]){n++,r=0;break}e+="\\"===t[n]?t[++n]:t[n]}if(r)throw new TypeError(`Unterminated quote at ${r}: ${f}`)}if(!e)throw new TypeError(`Missing parameter name at ${n}: ${f}`);return e}for(;n<t.length;){const e=t[n],o=l[e];if(o)yield{type:o,index:n++,value:e};else if("\\"===e)yield{type:"ESCAPED",index:n++,value:t[n++]};else if(":"===e){const e=r();yield{type:"PARAM",index:n,value:e}}else if("*"===e){const e=r();yield{type:"WILDCARD",index:n,value:e}}else yield{type:"CHAR",index:n,value:t[n++]}}return{type:"END",index:n,value:""}}(e));const o=function e(t){const o=[];for(;;){const i=r.text();i&&o.push({type:"text",value:n(i)});const s=r.tryConsume("PARAM");if(s){o.push({type:"param",name:s});continue}const u=r.tryConsume("WILDCARD");if(u){o.push({type:"wildcard",name:u});continue}if(!r.tryConsume("{"))return r.consume(t),o;o.push({type:"group",tokens:e("}")})}}("END");return new m(o)}function $(e,t,n){const r=e.map((e=>function(e,t,n){if("text"===e.type)return()=>[e.value];if("group"===e.type){const r=$(e.tokens,t,n);return e=>{const[t,...n]=r(e);return n.length?[""]:[t]}}const r=n||a;if("wildcard"===e.type&&!1!==n)return n=>{const o=n[e.name];if(null==o)return["",e.name];if(!Array.isArray(o)||0===o.length)throw new TypeError(`Expected "${e.name}" to be a non-empty array`);return[o.map(((t,n)=>{if("string"!=typeof t)throw new TypeError(`Expected "${e.name}/${n}" to be a string`);return r(t)})).join(t)]};return t=>{const n=t[e.name];if(null==n)return["",e.name];if("string"!=typeof n)throw new TypeError(`Expected "${e.name}" to be a string`);return[r(n)]}}(e,t,n)));return e=>{const t=[""];for(const n of r){const[r,...o]=n(e);t[0]+=r,t.push(...o)}return t}}function g(e,t={}){const{delimiter:n=u,end:r=!0,sensitive:o=!1,trailing:i=!0}=t,s=[],a=[],p=o?"":"i",c=(Array.isArray(e)?e:[e]).map((e=>e instanceof m?e:h(e,t)));for(const{tokens:e}of c)for(const t of x(e,0,[])){const e=v(t,n,s);a.push(e)}let f=`^(?:${a.join("|")})`;i&&(f+=`(?:${y(n)}$)?`),f+=r?"$":`(?=${y(n)}|$)`;return{regexp:new RegExp(f,p),keys:s}}function*x(e,t,n){if(t===e.length)return yield n;const r=e[t];if("group"===r.type){const o=n.slice();for(const n of x(r.tokens,0,o))yield*x(e,t+1,n)}else n.push(r);yield*x(e,t+1,n)}function v(e,t,n){let r="",o="",i=!0;for(let s=0;s<e.length;s++){const u=e[s];if("text"!==u.type)if("param"!==u.type&&"wildcard"!==u.type);else{if(!i&&!o)throw new TypeError(`Missing text after "${u.name}": ${f}`);"param"===u.type?r+=`(${w(t,i?"":o)}+)`:r+="([\\s\\S]+)",n.push(u),o="",i=!1}else r+=y(u.value),o+=u.value,i||(i=u.value.includes(t))}return r}function w(e,t){return t.length<2?e.length<2?`[^${y(e+t)}]`:`(?:(?!${y(e)})[^${y(t)}])`:e.length<2?`(?:(?!${y(t)})[^${y(e)}])`:`(?:(?!${y(t)}|${y(e)})[\\s\\S])`}t=e.TokenData=m;var k=e.__esModule;export{t as TokenData,k as __esModule,r as compile,e as default,o as match,n as parse,i as pathToRegexp,s as stringify};
